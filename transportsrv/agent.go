package transportsrv

import (
	"crypto/rsa"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"micaiahwallace/rewire/rwcrypto"
	"micaiahwallace/rewire/rwutils"
	"net"
	"os"

	"github.com/xtaci/smux"
)

// AgentKeyStatus indicates an agents registration on a transport server
type AgentKeyStatus int

const (
	// AgentKeyError indicates an error reading the key status
	AgentKeyError = iota

	// AgentRegistered indicates an agent is registered
	AgentRegistered

	// AgentPending indicates the agent is waiting on approval
	AgentPending

	// AgentBlacklist indicates the agent key is blacklisted
	AgentBlacklist

	// AgentUnknown indicates the agent key is not known on this server
	AgentUnknown
)

// AgentConnStatus is the current status of the connection
type AgentConnStatus int

const (
	// AgentDown lost connection
	AgentDown = iota

	// AgentUp connection active but not authenticated
	AgentUp

	// AgentAuth connected and authenticated
	AgentAuth
)

func (s AgentConnStatus) String() string {
	return []string{"AgentDown", "AgentUp", "AgentAuth"}[s]
}

// Agent is a remote agent connected to the transport server
type Agent struct {

	// id generated by public key
	ID string

	// registered agent public key
	Pubkey *rsa.PublicKey
}

// AgentConn represents an active agent connection
type AgentConn struct {

	// agent details
	Agent *Agent

	// agent net connection
	Conn *net.Conn

	// connection status
	Status AgentConnStatus

	// connected agent tcp smux stream
	Session *smux.Session
}

// NewAgentConn returns an active agent connection
func NewAgentConn(key *rsa.PublicKey, socket *net.Conn) *AgentConn {
	id, err := GenerateKeyID(key)
	if err != nil {
		fmt.Println("Unable to generate agent id")
		return nil
	}
	agent := Agent{
		ID:     id,
		Pubkey: key,
	}
	ac := AgentConn{
		Agent:  &agent,
		Status: AgentAuth,
		Conn:   socket,
	}
	return &ac
}

// GenerateKeyID hashes the public key as a unique id for the agent
func GenerateKeyID(key *rsa.PublicKey) (string, error) {
	bytes, err := rwcrypto.ExportKeyBytes(key, false)
	if err != nil {
		return "", err
	}
	hashed := sha256.Sum256(bytes)
	return hex.EncodeToString(hashed[:]), nil
}

// KeyStatus returns the registration status of an agent key
func (agent *Agent) KeyStatus() AgentKeyStatus {

	// Check if key exists in accepted keys
	if exists := rwutils.FileExists(fmt.Sprintf("keys/agent/accepted/%s", agent.ID)); exists {
		return AgentRegistered
	}

	// Check if key exists in pending keys
	if exists := rwutils.FileExists(fmt.Sprintf("keys/agent/pending/%s", agent.ID)); exists {
		return AgentPending
	}

	// Check if key exists in blacklist keys
	if exists := rwutils.FileExists(fmt.Sprintf("keys/agent/blacklist/%s", agent.ID)); exists {
		return AgentBlacklist
	}

	return AgentUnknown
}

// SetKeyStatus sets the agent to a status
func (agent *Agent) SetKeyStatus(status AgentKeyStatus) error {

	// get current status
	currentStatus := agent.KeyStatus()

	// ignore if status doesn't change
	if currentStatus == status {
		return nil
	}

	// get current path to key
	cpath := ""
	switch currentStatus {
	case AgentRegistered:
		cpath = fmt.Sprintf("keys/agent/accepted/%s", agent.ID)
	case AgentPending:
		cpath = fmt.Sprintf("keys/agent/pending/%s", agent.ID)
	case AgentBlacklist:
		cpath = fmt.Sprintf("keys/agent/blacklist/%s", agent.ID)
	}

	// remove old reference
	if cpath != "" {
		if err := os.Remove(cpath); err != nil {
			return err
		}
	}

	// create new status path
	npath := ""
	switch status {
	case AgentRegistered:
		npath = fmt.Sprintf("keys/agent/accepted/%s", agent.ID)
	case AgentPending:
		npath = fmt.Sprintf("keys/agent/pending/%s", agent.ID)
	case AgentBlacklist:
		npath = fmt.Sprintf("keys/agent/blacklist/%s", agent.ID)
	}

	// create a blank file at the new path
	if npath != "" {
		if _, err := os.Create(npath); err != nil {
			return err
		}
	} else {
		return errors.New("Unknown key status specified")
	}

	return nil
}
