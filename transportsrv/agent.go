package transportsrv

import (
	"crypto/rsa"
	"errors"
	"fmt"
	"micaiahwallace/rewire/rwcrypto"
	"micaiahwallace/rewire/rwutils"
	"net"
	"os"

	"github.com/xtaci/smux"
)

// Agent defines agent properties
type Agent struct {

	// id generated by public key
	ID string

	// registered agent public key
	Pubkey *rsa.PublicKey
}

// AgentConn represents an active agent connection
type AgentConn struct {

	// agent details
	Agent *Agent

	// agent net connection
	Conn *net.Conn

	// connection status
	Status AgentConnStatus

	// connected agent tcp smux stream
	Session *smux.Session
}

// NewAgentConn returns an active agent connection
func NewAgentConn(key *rsa.PublicKey, socket *net.Conn) *AgentConn {
	id, err := rwcrypto.GenerateKeyID(key)
	if err != nil {
		fmt.Println("Unable to generate agent id")
		return nil
	}
	agent := Agent{
		ID:     id,
		Pubkey: key,
	}
	ac := AgentConn{
		Agent:  &agent,
		Status: AgentAuth,
		Conn:   socket,
	}
	return &ac
}

// KeyStatus returns the registration status of an agent key
func (agent *Agent) KeyStatus() AgentKeyStatus {

	// Check if key exists in accepted keys
	if exists := rwutils.FileExists(KeyPath(AcceptedAgentKeyDir, agent.ID)); exists {
		return AgentRegistered
	}

	// Check if key exists in pending keys
	if exists := rwutils.FileExists(KeyPath(PendingAgentKeyDir, agent.ID)); exists {
		return AgentPending
	}

	// Check if key exists in blacklist keys
	if exists := rwutils.FileExists(KeyPath(BlacklistAgentKeyDir, agent.ID)); exists {
		return AgentBlacklist
	}

	return AgentUnknown
}

// SetKeyStatus sets the agent to a status
func (agent *Agent) SetKeyStatus(status AgentKeyStatus) error {

	// get current status
	currentStatus := agent.KeyStatus()

	// ignore if status doesn't change
	if currentStatus == status {
		return nil
	}

	// get current path to key
	cpath := ""
	switch currentStatus {
	case AgentRegistered:
		cpath = KeyPath(AcceptedAgentKeyDir, agent.ID)
	case AgentPending:
		cpath = KeyPath(PendingAgentKeyDir, agent.ID)
	case AgentBlacklist:
		cpath = KeyPath(BlacklistAgentKeyDir, agent.ID)
	}

	// remove old reference
	if cpath != "" {
		if err := os.Remove(cpath); err != nil {
			return err
		}
	}

	// create new status path
	npath := ""
	switch status {
	case AgentRegistered:
		npath = KeyPath(AcceptedAgentKeyDir, agent.ID)
	case AgentPending:
		npath = KeyPath(PendingAgentKeyDir, agent.ID)
	case AgentBlacklist:
		npath = KeyPath(BlacklistAgentKeyDir, agent.ID)
	}

	// create a blank file at the new path
	if npath != "" {
		if _, err := os.Create(npath); err != nil {
			return err
		}
	} else {
		return errors.New("Unknown target key status specified")
	}

	return nil
}
